import pandas as pd
import numpy as np # Pour np.nan

def select_random_unique_combined_entries(
    input_excel_path, 
    output_excel_path, 
    snippet_column_name="code_snippet", 
    filepath_column_name="filepath", # Pour le filtre .py optionnel
    smell_category_col="vulnerability", # Nouvelle colonne pour la condition d'unicité
    filter_for_py_files=True, # Option pour activer/désactiver le filtre .py
    num_to_select=150, 
    random_seed=None
):
    """
    Lit un fichier Excel, filtre optionnellement pour les fichiers .py, 
    sélectionne un nombre spécifié d'entrées aléatoires en s'assurant 
    que la combinaison de (snippet de code, catégorie de smell) est unique et valide,
    et les enregistre dans un nouveau fichier Excel.

    Args:
        input_excel_path (str): Chemin vers le fichier Excel d'entrée.
        output_excel_path (str): Chemin pour sauvegarder le fichier Excel de sortie.
        snippet_column_name (str): Nom de la colonne contenant les snippets de code.
        filepath_column_name (str): Nom de la colonne contenant les chemins des fichiers.
        smell_category_col (str): Nom de la colonne contenant la catégorie du smell/vulnérabilité.
        filter_for_py_files (bool): Si True, filtre pour ne garder que les fichiers .py.
        num_to_select (int): Nombre d'entrées aléatoires à sélectionner.
        random_seed (int, optional): Graine pour le générateur de nombres aléatoires.
    """
    try:
        df = pd.read_excel(input_excel_path)
        print(f"Fichier d'entrée '{input_excel_path}' lu avec succès. Nombre de lignes initial: {len(df)}")
    except FileNotFoundError:
        print(f"ERREUR : Le fichier d'entrée '{input_excel_path}' n'a pas été trouvé.")
        return
    except Exception as e:
        print(f"ERREUR : Impossible de lire le fichier Excel '{input_excel_path}': {e}")
        return

    # Vérification des colonnes nécessaires
    required_cols = [snippet_column_name, smell_category_col]
    if filter_for_py_files:
        required_cols.append(filepath_column_name)
    
    missing_cols = [col for col in required_cols if col not in df.columns]
    if missing_cols:
        print(f"ERREUR : Colonne(s) requise(s) manquante(s) : {', '.join(missing_cols)}.")
        print(f"Colonnes disponibles : {df.columns.tolist()}")
        return

    df_processed = df.copy() # Travailler sur une copie

    # 1. Optionnel : Filtrer pour ne garder que les fichiers .py
    if filter_for_py_files:
        df_processed[filepath_column_name] = df_processed[filepath_column_name].astype(str).fillna('') 
        py_file_mask = df_processed[filepath_column_name].str.lower().str.endswith(".py", na=False)
        df_processed = df_processed[py_file_mask]

        if df_processed.empty:
            print(f"Aucune entrée correspondant à des fichiers .py (colonne '{filepath_column_name}') n'a été trouvée. Le fichier de sortie ne sera pas créé.")
            return
        print(f"Nombre de lignes après filtrage pour les fichiers .py : {len(df_processed)}")

    # 2. Filtrer les snippets et les catégories de smell non valides
    # Remplacer les vrais NaN par une chaîne temporaire avant la conversion en str
    df_processed[snippet_column_name] = df_processed[snippet_column_name].fillna("__TEMP_NAN_SNIPPET__").astype(str)
    df_processed[smell_category_col] = df_processed[smell_category_col].fillna("__TEMP_NAN_CATEGORY__").astype(str)

    invalid_snippet_mask = (
        df_processed[snippet_column_name].str.strip() == ""
    ) | (
        df_processed[snippet_column_name] == "__TEMP_NAN_SNIPPET__"
    ) | (
        df_processed[snippet_column_name].str.lower() == "n/a"
    ) | (
        df_processed[snippet_column_name].str.lower().str.startswith("erreur:")
    ) | (
        df_processed[snippet_column_name].str.lower().str.contains("non traité")
    ) # Ajoutez d'autres placeholders d'erreur pour les snippets si nécessaire

    invalid_category_mask = (
        df_processed[smell_category_col].str.strip() == ""
    ) | (
        df_processed[smell_category_col] == "__TEMP_NAN_CATEGORY__"
    ) | (
         df_processed[smell_category_col].str.lower() == "n/a" # Si "n/a" peut aussi être une catégorie invalide
    )


    df_valid_entries = df_processed[~(invalid_snippet_mask | invalid_category_mask)]
    num_after_invalid_filter = len(df_valid_entries)
    print(f"Nombre de lignes après filtrage des snippets/catégories invalides/vides : {num_after_invalid_filter}")

    if num_after_invalid_filter == 0:
        print("Aucune entrée valide trouvée après filtrage. Le fichier de sortie ne sera pas créé.")
        return

    # 3. Garder uniquement les combinaisons uniques de (snippet, catégorie)
    df_unique_entries = df_valid_entries.drop_duplicates(subset=[snippet_column_name, smell_category_col], keep='first')
    num_unique_combinations = len(df_unique_entries)
    print(f"Nombre de lignes avec des combinaisons (snippet, catégorie) uniques et valides : {num_unique_combinations}")

    if num_unique_combinations == 0:
        print("Aucune combinaison (snippet, catégorie) unique et valide trouvée. Le fichier de sortie ne sera pas créé.")
        return
        
    # 4. Sélectionner aléatoirement N entrées
    actual_num_to_select = min(num_to_select, num_unique_combinations)
    
    if actual_num_to_select < num_to_select:
        print(f"Attention : Moins de {num_to_select} combinaisons (snippet, catégorie) uniques et valides disponibles. Sélection de {actual_num_to_select} entrées.")
    else:
        print(f"Sélection de {actual_num_to_select} entrées aléatoires avec des combinaisons (snippet, catégorie) uniques.")

    df_selected = df_unique_entries.sample(n=actual_num_to_select, random_state=random_seed)

    # Optionnel: Nettoyer les colonnes des chaînes temporaires NaN si elles sont toujours là
    # (elles ne devraient pas l'être dans df_selected car on a filtré sur ~invalid_snippet_mask)
    # df_selected[snippet_column_name] = df_selected[snippet_column_name].replace("__TEMP_NAN_SNIPPET__", np.nan)
    # df_selected[smell_category_col] = df_selected[smell_category_col].replace("__TEMP_NAN_CATEGORY__", np.nan)

    # S'assurer de sauvegarder les colonnes originales du DataFrame sélectionné
    # df_selected ne contiendra que les colonnes du df original pour les lignes sélectionnées.

    try:
        df_selected.to_excel(output_excel_path, index=False)
        print(f"Fichier avec {len(df_selected)} entrées aléatoires (combinaisons uniques) sauvegardé avec succès sous '{output_excel_path}'.")
    except Exception as e:
        print(f"ERREUR : Impossible d'écrire le fichier Excel de sortie '{output_excel_path}': {e}")

# --- Configuration ---
# REMPLACEZ CES VALEURS SI NÉCESSAIRE

# Fichier Excel d'entrée
INPUT_EXCEL_FILE_FOR_SAMPLING = "terraform_snyk_code_snippets_categories_uniques.xlsx" # Ou un autre fichier pertinent

# Nom du fichier Excel de sortie
OUTPUT_SAMPLED_UNIQUE_COMBOS_FILE = "terraform_snyk_code_snippets_categories_uniques2.xlsx"

# Nom de la colonne contenant les snippets de code
SNIPPET_COLUMN_NAME_CFG = "code_snippet"
# Nom de la colonne contenant les chemins des fichiers (utilisé si filter_for_py_files=True)
FILEPATH_COLUMN_NAME_CFG = "filepath" 
# Nom de la colonne contenant la catégorie du smell/vulnérabilité
# D'après votre exemple CSV, cela correspondrait à 'vulnerability'
SMELL_CATEGORY_COLUMN_CFG = "vulnerability" 

# Activer ou désactiver le filtre pour les fichiers .py
FILTER_FOR_PY_FILES_CFG = False # Mettez à False si vous ne voulez pas filtrer par .py

# Nombre d'entrées à sélectionner
NUMBER_OF_ENTRIES_TO_SELECT_CFG = 1000

# Graine pour la sélection aléatoire
RANDOM_SEED_FOR_SAMPLING_CFG = 42 
# --------------------

if __name__ == "__main__":
    select_random_unique_combined_entries(
        INPUT_EXCEL_FILE_FOR_SAMPLING,
        OUTPUT_SAMPLED_UNIQUE_COMBOS_FILE,
        snippet_column_name=SNIPPET_COLUMN_NAME_CFG,
        filepath_column_name=FILEPATH_COLUMN_NAME_CFG,
        smell_category_col=SMELL_CATEGORY_COLUMN_CFG,
        filter_for_py_files=FILTER_FOR_PY_FILES_CFG,
        num_to_select=NUMBER_OF_ENTRIES_TO_SELECT_CFG,
        random_seed=RANDOM_SEED_FOR_SAMPLING_CFG
    )
